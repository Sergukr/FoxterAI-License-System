//+------------------------------------------------------------------+
//|                                                   13_license.mqh |
//|                     Модуль лицензирования для FoxterAI v2.0     |
//|              ПОЛНАЯ ПЕРЕДАЧА ДАННЫХ + 3 ДНЯ АВТОНОМНОЙ РАБОТЫ  |
//+------------------------------------------------------------------+

#import "wininet.dll"
    int InternetOpenW(string agent, int accessType, string proxyName, string proxyBypass, int flags);
    int InternetConnectW(int internet, string serverName, int port, string userName, string password, 
                        int service, int flags, int context);
    int HttpOpenRequestW(int connect, string verb, string objectName, string version, string referer, 
                        int &acceptTypes, int flags, int context);
    bool HttpSendRequestW(int request, string headers, int headersLength, uchar &buffer[], int bufferLength);
    int InternetReadFile(int request, uchar &buffer[], int bufferSize, int &bytesRead[]);
    int InternetCloseHandle(int handle);
#import

//--- Состояния лицензии
#define LICENSE_UNCHECKED 0     // Не проверена
#define LICENSE_VALID 1         // Действительна
#define LICENSE_EXPIRED 2       // Истекла
#define LICENSE_INVALID 3       // Недействительна
#define LICENSE_BLOCKED 4       // Заблокирована
#define LICENSE_NO_CONNECTION 5 // Нет связи с сервером
#define LICENSE_GRACE_PERIOD 6  // Грейс-период (работа без связи)

//--- Глобальные переменные лицензии
int g_LicenseState = LICENSE_UNCHECKED;
string g_LicenseKey = "";
datetime g_LicenseExpiry = 0;
datetime g_LastSuccessfulCheck = 0;
datetime g_LastCheckAttempt = 0;
int g_FailedChecks = 0;
bool g_LicenseActivated = false;
string g_LicenseMessage = "";

//--- КОНСТАНТЫ РОБОТА v2.0 (ОБНОВЛЕНО!)
#define ROBOT_NAME "FoxterAI"           // Реальное название робота
#define ROBOT_VERSION "2.0"              // ВЕРСИЯ 2.0 С ЛОКАЛЬНЫМ ХРАНЕНИЕМ!

//--- ЖЕСТКО ЗАШИТЫЕ НАСТРОЙКИ СЕРВЕРА
#define LICENSE_SERVER_URL "178.130.43.120"
#define LICENSE_SERVER_PORT 3000

//--- Константы флагов WinInet (исправлены для MQL4)
#define INTERNET_FLAG_RELOAD            -2147483648  // 0x80000000 как signed int
#define INTERNET_FLAG_NO_CACHE_WRITE    67108864     // 0x04000000
#define INTERNET_FLAG_PRAGMA_NOCACHE    256          // 0x00000100  
#define INTERNET_FLAG_NO_UI             512          // 0x00000200

//--- ИЗМЕНЕНО: УМЕНЬШЕНЫ ВРЕМЕННЫЕ ИНТЕРВАЛЫ
#define LICENSE_CHECK_INTERVAL 86400      // Проверка раз в СУТКИ (24 часа)
#define LICENSE_HEARTBEAT_INTERVAL 43200  // Heartbeat раз в 12 ЧАСОВ
#define LICENSE_GRACE_PERIOD_HOURS 72     // 3 ДНЯ работы без связи
#define MAX_FAILED_CHECKS 3               // 3 неудачных попытки = 3 дня
#define LICENSE_WARNING_DAYS 7            // Предупреждение за 7 дней до истечения

//+------------------------------------------------------------------+
//| ПРОВЕРКА НА ТЕСТЕР                                              |
//+------------------------------------------------------------------+
bool IsTestMode() {
    return (IsTesting() || IsOptimization() || IsVisualMode());
}

//+------------------------------------------------------------------+
//| ОПРЕДЕЛЕНИЕ ТИПА СЧЕТА (ДЕМО/РЕАЛ)                             |
//+------------------------------------------------------------------+
string GetAccountType() {
    if(IsTestMode()) return "Tester";
    
    // Способ 1: Проверка через IsDemo()
    if(IsDemo()) return "Demo";
    
    // Способ 2: Дополнительная проверка через название сервера
    string broker = AccountCompany();
    string brokerLower = broker;
    StringToLower(brokerLower);
    
    if(StringFind(brokerLower, "demo") >= 0 || 
       StringFind(brokerLower, "contest") >= 0 ||
       StringFind(brokerLower, "virtual") >= 0) {
        return "Demo";
    }
    
    return "Real";
}

//+------------------------------------------------------------------+
//| БЕЗОПАСНОЕ ПОЛУЧЕНИЕ ИМЕНИ ВЛАДЕЛЬЦА СЧЕТА                      |
//+------------------------------------------------------------------+
string GetAccountOwnerSafe() {
    if(IsTestMode()) return "Tester";
    
    string owner = AccountName();
    
    // Если имя пустое или содержит только пробелы
    if(StringLen(owner) == 0 || StringTrimLeft(StringTrimRight(owner)) == "") {
        return "Account_" + IntegerToString(AccountNumber());
    }
    
    // Проверяем, не является ли строка набором Unicode-кодов
    if(StringFind(owner, "[") == 0 && StringFind(owner, "]") > 0) {
        return "Account_" + IntegerToString(AccountNumber());
    }
    
    // Проверяем на наличие только ASCII символов
    bool hasValidChars = false;
    string safeOwner = "";
    
    for(int i = 0; i < StringLen(owner) && i < 30; i++) {
        ushort charCode = StringGetCharacter(owner, i);
        
        // Принимаем только безопасные символы
        if((charCode >= 'A' && charCode <= 'Z') || 
           (charCode >= 'a' && charCode <= 'z') ||
           (charCode >= '0' && charCode <= '9') ||
           charCode == ' ' || charCode == '.' || charCode == '-' || charCode == '_') {
            safeOwner = safeOwner + CharToString((uchar)charCode);
            hasValidChars = true;
        }
        else if(charCode > 127) {
            // Кириллица или другие не-ASCII символы - заменяем на X
            safeOwner = safeOwner + "X";
            hasValidChars = true;
        }
    }
    
    // Если после фильтрации получили валидные символы
    if(hasValidChars && StringLen(safeOwner) > 0) {
        string trimmed = StringTrimLeft(StringTrimRight(safeOwner));
        if(StringLen(trimmed) > 0) {
            return trimmed;
        }
    }
    
    // Если ничего не получилось - используем номер счета
    return "Account_" + IntegerToString(AccountNumber());
}

//+------------------------------------------------------------------+
//| ПОЛУЧЕНИЕ ОТПЕЧАТКА СИСТЕМЫ v2.0                                |
//+------------------------------------------------------------------+
string GetSystemFingerprint() {
    if(IsTestMode()) {
        return "TESTER_MODE";
    }
    
    // Создаем отпечаток на основе: счет + робот + версия 2.0
    string fingerprint = "";
    fingerprint = fingerprint + IntegerToString(AccountNumber());
    fingerprint = fingerprint + "_" + ROBOT_NAME;
    fingerprint = fingerprint + "_" + ROBOT_VERSION;
    
    // Простое хэширование
    int hash = 0;
    for(int i = 0; i < StringLen(fingerprint); i++) {
        hash = hash * 31 + StringGetCharacter(fingerprint, i);
    }
    
    return IntegerToString(MathAbs(hash));
}

//+------------------------------------------------------------------+
//| ОТПРАВКА HTTP ЗАПРОСА v2.0                                      |
//+------------------------------------------------------------------+
string SendHTTPRequest(string endpoint, string postData) {
    if(IsTestMode()) {
        return "{\"success\":true,\"message\":\"Test mode\"}";
    }
    
    //--- Открываем интернет соединение (с версией 2.0!)
    int hInternet = InternetOpenW("FoxterAI/2.0", 1, "", "", 0);
    if(hInternet == 0) {
        int error = GetLastError();
        
        hInternet = InternetOpenW("Mozilla/5.0", 0, "", "", 0);
        if(hInternet == 0) {
            return "";
        }
    }
    
    //--- Подключаемся к серверу
    int hConnect = InternetConnectW(hInternet, LICENSE_SERVER_URL, LICENSE_SERVER_PORT, 
                                   "", "", 3, 0, 0);
    if(hConnect == 0) {
        InternetCloseHandle(hInternet);
        return "";
    }
    
    //--- Создаем HTTP запрос
    int flags = INTERNET_FLAG_RELOAD | INTERNET_FLAG_NO_CACHE_WRITE | 
                INTERNET_FLAG_PRAGMA_NOCACHE | INTERNET_FLAG_NO_UI;
    
    int acceptTypes = 0;
    int hRequest = HttpOpenRequestW(hConnect, "POST", endpoint, "HTTP/1.1", "", 
                                   acceptTypes, flags, 0);
    if(hRequest == 0) {
        InternetCloseHandle(hConnect);
        InternetCloseHandle(hInternet);
        return "";
    }
    
    //--- Конвертируем данные в массив байт
    uchar postDataArray[];
    int dataLen = StringLen(postData);
    ArrayResize(postDataArray, dataLen);
    StringToCharArray(postData, postDataArray, 0, dataLen);
    
    //--- Отправляем запрос
    string headers = "Content-Type: application/json\r\nConnection: close\r\n";
    
    if(!HttpSendRequestW(hRequest, headers, StringLen(headers), postDataArray, ArraySize(postDataArray))) {
        InternetCloseHandle(hRequest);
        InternetCloseHandle(hConnect);
        InternetCloseHandle(hInternet);
        return "";
    }
    
    //--- Читаем ответ
    uchar buffer[4096];
    int bytesRead[1];
    string response = "";
    int totalBytes = 0;
    
    while(true) {
        if(!InternetReadFile(hRequest, buffer, ArraySize(buffer) - 1, bytesRead)) {
            break;
        }
        
        if(bytesRead[0] <= 0) {
            break;
        }
        
        string chunk = CharArrayToString(buffer, 0, bytesRead[0]);
        response = response + chunk;
        totalBytes = totalBytes + bytesRead[0];
        
        if(totalBytes > 100000) {
            break;
        }
    }
    
    //--- Закрываем все хэндлы
    InternetCloseHandle(hRequest);
    InternetCloseHandle(hConnect);
    InternetCloseHandle(hInternet);
    
    return response;
}

//+------------------------------------------------------------------+
//| АКТИВАЦИЯ ЛИЦЕНЗИИ v2.0                                         |
//+------------------------------------------------------------------+
bool ActivateLicense() {
    if(IsTestMode()) {
        g_LicenseState = LICENSE_VALID;
        g_LicenseActivated = true;
        g_LastSuccessfulCheck = TimeCurrent();
        g_LicenseMessage = "Тестовый режим - лицензия не требуется";
        return true;
    }
    
    //--- Собираем ВСЕ данные для активации
    string accountOwner = GetAccountOwnerSafe();
    string accountType = GetAccountType();
    double balance = AccountBalance();
    
    //--- Подготавливаем расширенные данные для отправки
    string postData = "{";
    postData = postData + "\"key\":\"" + g_LicenseKey + "\",";
    postData = postData + "\"account\":\"" + IntegerToString(AccountNumber()) + "\",";
    postData = postData + "\"account_owner\":\"" + accountOwner + "\",";  
    postData = postData + "\"broker\":\"" + AccountCompany() + "\",";
    postData = postData + "\"robot_name\":\"" + ROBOT_NAME + "\",";       
    postData = postData + "\"robot_version\":\"" + ROBOT_VERSION + "\","; // v2.0!
    postData = postData + "\"balance\":" + DoubleToString(balance, 2) + ",";
    postData = postData + "\"account_type\":\"" + accountType + "\",";    
    postData = postData + "\"fingerprint\":\"" + GetSystemFingerprint() + "\"";
    postData = postData + "}";
    
    Print("=====================================");
    Print("       АКТИВАЦИЯ ЛИЦЕНЗИИ v2.0");
    Print("=====================================");
    Print("Счет: ", AccountNumber());
    Print("=====================================");
    
    //--- Отправляем запрос
    string response = SendHTTPRequest("/activate", postData);
    
    if(response == "") {
        g_LicenseState = LICENSE_NO_CONNECTION;
        g_LicenseMessage = "Нет связи с сервером лицензий";
        return false;
    }
    
    //--- Парсим ответ
    if(StringFind(response, "\"success\":true") >= 0) {
        Print("✅ Активация подтверждена");
        
        g_LicenseState = LICENSE_VALID;
        g_LicenseActivated = true;
        g_LastSuccessfulCheck = TimeCurrent();
        g_FailedChecks = 0;
        g_LicenseMessage = "Лицензия активирована успешно";
        
        return true;
    }
    else if(StringFind(response, "не найден") >= 0 || StringFind(response, "not found") >= 0) {
        g_LicenseState = LICENSE_INVALID;
        g_LicenseMessage = "Лицензионный ключ не найден на сервере";
        Print("❌ Ключ не существует!");
        return false;
    }
    else if(StringFind(response, "уже активирована на другом счете") >= 0 || 
            StringFind(response, "привязана к другому счету") >= 0 ||
            StringFind(response, "wrong_account") >= 0) {
        g_LicenseState = LICENSE_INVALID;
        g_LicenseMessage = "Лицензия привязана к другому счету";
        Print("❌ Лицензия привязана к другому счету!");
        return false;
    }
    else if(StringFind(response, "другому роботу") >= 0 || StringFind(response, "wrong_robot") >= 0) {
        g_LicenseState = LICENSE_INVALID;
        g_LicenseMessage = "Лицензия привязана к другому роботу";
        Print("❌ Лицензия привязана к другому роботу!");
        return false;
    }
    else if(StringFind(response, "заблокирована") >= 0 || StringFind(response, "blocked") >= 0) {
        g_LicenseState = LICENSE_BLOCKED;
        g_LicenseMessage = "Лицензия заблокирована";
        return false;
    }
    else if(StringFind(response, "истекла") >= 0 || StringFind(response, "expired") >= 0) {
        g_LicenseState = LICENSE_EXPIRED;
        g_LicenseMessage = "Срок действия лицензии истек";
        return false;
    }
    
    g_LicenseState = LICENSE_INVALID;
    g_LicenseMessage = "Ошибка активации";
    return false;
}

//+------------------------------------------------------------------+
//| ПРОВЕРКА ЛИЦЕНЗИИ v2.0                                          |
//+------------------------------------------------------------------+
bool CheckLicense(bool isInitialCheck = false) {
    if(IsTestMode()) {
        if(g_LicenseState != LICENSE_VALID) {
            g_LicenseState = LICENSE_VALID;
            g_LicenseActivated = true;
            g_LicenseMessage = "Тестовый режим";
        }
        return true;
    }
    
    //--- При первом запуске всегда проверяем
    if(isInitialCheck) {
        Print("Проверка лицензии...");
        
        bool result = ActivateLicense();
        g_LastCheckAttempt = TimeCurrent();
        return result;
    }
    
    //--- Проверяем интервал между проверками
    if(TimeCurrent() - g_LastCheckAttempt < LICENSE_CHECK_INTERVAL) {
        return (g_LicenseState == LICENSE_VALID);
    }
    
    g_LastCheckAttempt = TimeCurrent();
    
    Print("Ежедневная проверка лицензии...");
    
    //--- Передаем название и версию робота при проверке
    string postData = "{";
    postData = postData + "\"key\":\"" + g_LicenseKey + "\",";
    postData = postData + "\"account\":\"" + IntegerToString(AccountNumber()) + "\",";
    postData = postData + "\"broker\":\"" + AccountCompany() + "\",";
    postData = postData + "\"robot_name\":\"" + ROBOT_NAME + "\",";       
    postData = postData + "\"robot_version\":\"" + ROBOT_VERSION + "\","; // v2.0!
    postData = postData + "\"fingerprint\":\"" + GetSystemFingerprint() + "\"";
    postData = postData + "}";
    
    //--- Отправляем запрос
    string response = SendHTTPRequest("/check", postData);
    
    if(response == "") {
        g_FailedChecks++;
        Print("⚠️ Нет связи с сервером, попыток: ", g_FailedChecks, " из ", MAX_FAILED_CHECKS);
        
        // Даем только 3 ДНЯ работы без связи
        if(g_FailedChecks >= MAX_FAILED_CHECKS) {
            g_LicenseState = LICENSE_NO_CONNECTION;
            g_LicenseMessage = "Потеряна связь с сервером лицензий более 3 дней";
            Alert("КРИТИЧНО: Нет связи с сервером лицензий более 3 дней!\nРобот будет остановлен!");
            return false;
        }
        
        // Предупреждения
        if(g_LicenseActivated) {
            if(g_FailedChecks == 1) {
                Print("Работаем в автономном режиме (день 1 из 3)");
            } else if(g_FailedChecks == 2) {
                Alert("ВНИМАНИЕ: Нет связи с сервером 2 дня!\nОсталось 1 день до блокировки!");
            }
        }
        
        // Временно разрешаем работу
        return (g_LicenseState == LICENSE_VALID || g_LicenseActivated);
    }
    
    // Сбрасываем счетчик при успешной связи
    g_FailedChecks = 0;
    
    //--- Парсим ответ
    if(StringFind(response, "\"success\":true") >= 0) {
        g_LicenseState = LICENSE_VALID;
        g_LastSuccessfulCheck = TimeCurrent();
        g_LicenseMessage = "Лицензия действительна";
        Print("✅ Лицензия действительна");
        return true;
    }
    else if(StringFind(response, "не найден") >= 0 || StringFind(response, "not found") >= 0) {
        g_LicenseState = LICENSE_INVALID;
        g_LicenseMessage = "Лицензия удалена с сервера";
        Print("❌ Лицензия не найдена!");
        Alert("Лицензия удалена с сервера!\nРобот остановлен.");
        return false;
    }
    else if(StringFind(response, "истекла") >= 0 || StringFind(response, "expired") >= 0) {
        g_LicenseState = LICENSE_EXPIRED;
        g_LicenseMessage = "Срок действия лицензии истек";
        Print("⚠️ Лицензия истекла!");
        Alert("Срок действия лицензии истек!\nОбратитесь за продлением.");
        return false;
    }
    else if(StringFind(response, "заблокирована") >= 0 || StringFind(response, "blocked") >= 0) {
        g_LicenseState = LICENSE_BLOCKED;
        g_LicenseMessage = "Лицензия заблокирована администратором";
        Print("❌ Лицензия заблокирована!");
        Alert("Лицензия заблокирована администратором!");
        return false;
    }
    else if(StringFind(response, "другому счету") >= 0 || StringFind(response, "wrong_account") >= 0) {
        g_LicenseState = LICENSE_INVALID;
        g_LicenseMessage = "Лицензия привязана к другому счету";
        Print("❌ Лицензия привязана к другому счету!");
        return false;
    }
    else if(StringFind(response, "другому роботу") >= 0 || StringFind(response, "wrong_robot") >= 0) {
        g_LicenseState = LICENSE_INVALID;
        g_LicenseMessage = "Лицензия привязана к другому роботу";
        Print("❌ Лицензия привязана к другому роботу!");
        return false;
    }
    
    g_LicenseState = LICENSE_INVALID;
    g_LicenseMessage = "Лицензия недействительна";
    Print("❌ Лицензия недействительна");
    return false;
}

//+------------------------------------------------------------------+
//| ОТПРАВКА HEARTBEAT v2.0                                         |
//+------------------------------------------------------------------+
void SendHeartbeat() {
    if(IsTestMode()) return;
    
    static datetime lastHeartbeat = 0;
    
    if(TimeCurrent() - lastHeartbeat < LICENSE_HEARTBEAT_INTERVAL) return;
    
    if(g_LicenseState != LICENSE_VALID && !g_LicenseActivated) return;
    
    lastHeartbeat = TimeCurrent();
    
    //--- Передаем расширенную статистику
    string accountType = GetAccountType();
    double balance = AccountBalance();
    double equity = AccountEquity();
    double profit = equity - balance;
    
    string postData = "{";
    postData = postData + "\"key\":\"" + g_LicenseKey + "\",";
    postData = postData + "\"account\":\"" + IntegerToString(AccountNumber()) + "\",";
    postData = postData + "\"broker\":\"" + AccountCompany() + "\",";
    postData = postData + "\"robot_name\":\"" + ROBOT_NAME + "\",";       
    postData = postData + "\"version\":\"" + ROBOT_VERSION + "\",";  // v2.0!     
    postData = postData + "\"account_type\":\"" + accountType + "\",";    
    postData = postData + "\"balance\":" + DoubleToString(balance, 2) + ",";
    postData = postData + "\"equity\":" + DoubleToString(equity, 2) + ","; 
    postData = postData + "\"profit\":" + DoubleToString(profit, 2);      
    postData = postData + "}";
    
    SendHTTPRequest("/heartbeat", postData);
}

//+------------------------------------------------------------------+
//| ПРОВЕРКА РАЗРЕШЕНИЯ НА ТОРГОВЛЮ                                 |
//+------------------------------------------------------------------+
bool IsLicenseValidForTrading() {
    if(IsTestMode()) return true;
    
    // Разрешаем работу максимум 3 дня без связи
    return (g_LicenseState == LICENSE_VALID || 
            (g_LicenseActivated && g_FailedChecks < MAX_FAILED_CHECKS));
}

//+------------------------------------------------------------------+
//| ПОЛУЧЕНИЕ СТАТУСА ЛИЦЕНЗИИ ДЛЯ ОТОБРАЖЕНИЯ                     |
//+------------------------------------------------------------------+
string GetLicenseStatusText() {
    if(IsTestMode()) {
        return "ТЕСТЕР";
    }
    
    if(g_LicenseState == LICENSE_VALID) {
        if(g_FailedChecks > 0) {
            return "Автоном " + IntegerToString(g_FailedChecks) + "/3д";
        }
        return "Активна";
    }
    else if(g_LicenseState == LICENSE_EXPIRED) {
        return "Истекла";
    }
    else if(g_LicenseState == LICENSE_INVALID) {
        return "Недействит.";
    }
    else if(g_LicenseState == LICENSE_BLOCKED) {
        return "Заблокир.";
    }
    else if(g_LicenseState == LICENSE_NO_CONNECTION) {
        return "Нет связи";
    }
    else if(g_LicenseActivated && g_FailedChecks > 0) {
        return "Автоном " + IntegerToString(g_FailedChecks) + "/3д";
    }
    else {
        return "Не проверена";
    }
}

//+------------------------------------------------------------------+
//| ПОЛУЧЕНИЕ ЦВЕТА СТАТУСА                                          |
//+------------------------------------------------------------------+
color GetLicenseStatusColor() {
    if(IsTestMode()) {
        return C'33,150,243';  // Синий для тестера
    }
    
    if(g_LicenseState == LICENSE_VALID && g_FailedChecks == 0) {
        return C'76,175,80';  // Зеленый
    }
    else if(g_FailedChecks == 1) {
        return C'255,193,7';  // Желтый - день 1
    }
    else if(g_FailedChecks == 2) {
        return C'255,152,0';  // Оранжевый - день 2
    }
    else if(g_FailedChecks >= 3 || g_LicenseState == LICENSE_NO_CONNECTION) {
        return C'244,67,54';  // Красный - критично
    }
    else {
        return C'244,67,54';  // Красный для всех невалидных
    }
}

//+------------------------------------------------------------------+
//| ИНИЦИАЛИЗАЦИЯ ЛИЦЕНЗИИ v2.0                                     |
//+------------------------------------------------------------------+
bool InitializeLicense(string licenseKey) {
    if(IsTestMode()) {
        g_LicenseKey = "UNIV-TEST-MODE-KEY";
        g_LicenseState = LICENSE_VALID;
        g_LicenseActivated = true;
        g_LicenseMessage = "Тестовый режим - лицензия не требуется";
        
        Print("=====================================");
        Print("    РЕЖИМ ТЕСТЕРА СТРАТЕГИЙ");
        Print("=====================================");
        Print("Лицензия автоматически активирована");
        Print("=====================================");
        
        return true;
    }
    
    g_LicenseKey = licenseKey;
    
    Print("=====================================");
    Print("    ИНИЦИАЛИЗАЦИЯ СИСТЕМЫ v2.0");
    Print("=====================================");
    Print("Счет: ", AccountNumber());
    Print("=====================================");
    
    // Сбрасываем состояние
    g_LicenseState = LICENSE_UNCHECKED;
    g_LicenseActivated = false;
    g_LastSuccessfulCheck = 0;
    g_FailedChecks = 0;
    
    //--- Проверяем лицензию на сервере
    bool result = CheckLicense(true);
    
    Print("=====================================");
    Print("Результат: ", result ? "УСПЕХ" : "ОШИБКА");
    if(!result) {
        Print("Причина: ", g_LicenseMessage);
    } else {
        Print("Следующая проверка через 24 часа");
        Print("Автономная работа: максимум 3 дня");
    }
    Print("=====================================");
    
    return result;
}

//+------------------------------------------------------------------+
//| ПОЛНАЯ ОЧИСТКА ДАННЫХ ЛИЦЕНЗИИ v2.0                            |
//+------------------------------------------------------------------+
void ClearAllLicenseData() {
    if(IsTestMode()) return;
    
    // НОВОЕ: Удаляем из локального хранилища v2.0
    string licenseFile = "FoxterAI/" + IntegerToString(AccountNumber()) + "/license.key";
    FileDelete(licenseFile);
    
    // Сбрасываем переменные в памяти
    g_LicenseState = LICENSE_UNCHECKED;
    g_LicenseKey = "";
    g_LicenseExpiry = 0;
    g_LastSuccessfulCheck = 0;
    g_LastCheckAttempt = 0;
    g_FailedChecks = 0;
    g_LicenseActivated = false;
    g_LicenseMessage = "";
    
    Print("✅ Данные лицензии очищены из локального хранилища v2.0");
}

// ========================================================
// СТАРЫЕ ФУНКЦИИ УДАЛЕНЫ! Теперь используются новые из модуля 15:
// - SaveLicenseKeyLocal() вместо SaveLicenseKeyToFile()
// - GetLicenseKeyLocal() вместо GetSavedLicenseKey()
// ========================================================